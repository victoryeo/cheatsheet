# kubectl command auto completion 
source <(kubectl completion bash)

# watch the cronjob as they are being scheduled
kubectl get cronjob --watch

# show cronjob successfulJobsHistoryLimit
kubectl get cronjobs <job_name> -o yaml

# update nginx image to latest version
kubectl set image deployment/<deploy_name> nginx=nginx:latest

# verift rollout history
kubectl rollout history deploy <deploy_name> --revision=2

# revert the deployment to revision 1
kubectl rollout undo deployment <deploy_name> --to-revision=1

# create a pod with nginx image and export port 80
kubectl run pod1 --image=nginx:2.3.5 --port=80  --dry-run=client -o yaml

# run a temporary pod
kubectl run busybox --image=busybox --rm -it -- /bin/sh

# find pod with selector value of example
kubectl get pod -l app=example

# show pod labels
kubectl get pod --show-labels=true

# show labels belonging to web and batch in prod
kubectl get pod -l 'env in (prod), tier in (web,batch)'

# unlabel a pod
k label pod pod9 tier-

# check for ingress controller conflict (if got more than one ingress controller)
kubectl get svc -A | grep LoadBalancer

# get endpoint, to observe ip addresses assigned to pods
kubectl get ep

# show list of ingress
kubectl get ing -n <namespace>

# see events
kubectl get events --sort-by=.metadata.creationTimestamp -n <namespace>

# get keda scaled object from all namespaces
kubectl get scaledobject -A

# create a generic secret with literal value
kubectl create secret generic my-secret --from-literal=db-password=speed --from-literal=password=mach5

# deploy container to k8s pod
kubectl create deployment <deployment_name> --image=<container> -n <namespace>
kubectl create deployment bqdinator --image=asia.gcr.io/mycompany-blockchain-stg/bqdinator:latest -n myproject
# deploy a nginx pod
kubectl create deployment nginxapp --image=nginx:1.14.2
# create quota
kubectl create quota my-quota --hard=cpu=1,memory=500M,pods=2 --dry-run=client -o yaml -n rq-demo 

# describe deployment
kubectl describe deployment <deployment_name> -n <namespace>
# describe secret
kubectl describe secret <secret_name>
# describe ingress routes
kubectl describe ingress <ingress_name> -n <namespace>
# describe pod (to find pod's external ip address)
kubectl describe pod <podname> -n <namespace> 
# show specific ingress details
kubectl describe ing <ingress_name> -n <namespace> 

# apply k8s ingress yaml file
kubectl apply -f <k8s_yaml>.yml

# see logs
kubectl get pods -n gitlab-managed-apps
kubectl logs install-helm -n gitlab-managed-apps

# access log of previously crashed pod
kubectl logs --tail=10 <POD-NAME> -p

# create a pod
kubectl create -f ./config-example.yaml -n <namespace>

# delete a pod
kubectl delete -f ./config-example.yaml -n <namespace>

# delete a pod
kubectl delete pod  <pod_name>  -n <namespace>

# delete a deployment
kubectl delete deployment <deployment_name> -n <namespace>

# show list of k8s contexts
kubectl config get-contexts

# use the context of cluster
kubectl config use-context <CLUSTER_NAME>

# switch namespace
kubectl config set-context --current --namespace=newns

# show current cluster
kubectl config current-context

# delete cluster from ~/.kube/config
kubectl config delete-context <CLUSTER_NAME>

# delete cluster/context/user entries
kubectl config unset users.gke_project_zone_name

kubectl config unset contexts.aws_cluster1-kubernetes

kubectl config unset clusters.foobar-baz


# to connect to a pod command line
kubectl exec nginx-f89759699-2gbwc  -it -- bash
# connect to container in pod
kubectl -n <namespace> exec <pod> --container <container_name> -it -- bash
# connect to postgres container
kubectl exec -it <pod> -c postgresql -- psql -U postgres -p 5432
# enter redis pod and run redis-cli tool
kubectl exec -it redis-pod -- redis-cli
# get env variable
kubectl exec -it <pod_name> -- env

# live log
kubectl -n bc logs peer0-ade-hlf-peer-797894965c-cvrxd --tail 1 --follow
kubectl -n bc logs peer0-ade-hlf-peer-797894965c-cvrxd --tail 1 -f

# scale deployment replicas
kubectl scale deployment <name> --replicas=10

# get namespace
kubectl get namespace
# get service
kubectl get svc -n <namespace>
kubectl get service -n <namespace>
kubectl get service -n <namespace> -o wide

# get service of current context
kubectl --context CURRENT_CONTEXT get svc
kubectl --context arn:aws:eks:us-west-2:151215527701:cluster/sube-cluster-tf get svc

# copy file to a container in a specific pod
kubectl cp /home/Downloads/tokendata.csv kafka-proxy-85557c4ddb-k9zhp:/tmp/ -c postgresql

# open aws-auth configmap for editing
kubectl edit -n kube-system configmap/aws-auth
# reading aws-auth configmap
kubectl describe -n kube-system configmap/aws-auth

# to untaint nodes
kubectl taint nodes --all eks.amazonaws.com/compute-type=fargate:NoSchedule-

# to check CSI driver version
kubectl explain CSIDriver

# check pods spec containers syntax
kubectl explain pods.spec.containers.port

# krew plugin manager, list all plugins installed
kubectl krew list

# install ctx plugin via krew
kubectl krew install ctx
kubectl ctx

# if resource-capacity plugin is installed, we can run the command
kubectl resource-capacity
